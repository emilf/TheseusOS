# USB Keyboard Driver – Milestone 3 (xHCI Bring-Up)

Milestone 3 focuses on bringing the xHCI host controller online with modern practices so later stages can layer USB protocol support without revisiting firmware handoff or DMA plumbing.

## Completed Work This Iteration
- **Scratchpad infrastructure**: The driver now decodes `HCSParams2`, allocates the scratchpad pointer table, and provisions aligned DMA buffers when the controller advertises a non-zero count (`kernel/src/drivers/usb/xhci/mod.rs:1242`). DCBAA entry 0 is updated automatically so future slot/context setup can assume the scratchpad array is ready.
- **Capability telemetry**: Capability logging now reports the required scratchpad count alongside slots, ports, and context size, making controller expectations visible in the serial log (`kernel/src/drivers/usb/xhci/mod.rs:1491`).
- **Port diagnostics**: After RUN is asserted the driver walks each root port, emitting a structured summary (link state, speed, power, reset) and highlighting the first connected port to seed enumeration decisions (`kernel/src/drivers/usb/xhci/mod.rs:1569`).
- **Context scaffolding**: Device-context allocations now respect the controller's advertised context size, record the stride once per controller, expose slice-based helpers for slot/endpoint access, prime the input context for the default control endpoint using the first connected port, and immediately issue Enable Slot/Address Device commands to capture the assigned slot ID (`kernel/src/drivers/usb/xhci/mod.rs:1621`).
- **Documentation coverage**: Every helper added for scratchpads and port introspection carries Rustdoc comments so new contributors can follow the flow without cross-referencing the xHCI spec.
- **EP0 control path**: Route-string handling now matches the xHCI expectation (root ports advertise a zero route string), command TRB type constants line up with the spec, and the transfer ring producer no longer rewinds without informing hardware. Together these fixes allow the BSR sequence, evaluate-context, and configure-endpoint commands to succeed, and the driver captures both the 8-byte prefix and the full 18-byte device descriptor under QEMU.
- **Ring lifecycle diagnostics**: Pulling the control transfer ring’s enqueue indices into the debug logs (rather than always dumping TRBs 0–2) makes it obvious which slots are reused across transfers and confirmed that the controller consumes the data stage before raising the status-stage completion.
- **Configuration descriptor discovery**: The enumeration helper now reads the configuration descriptor header, refetches the full descriptor, walks the descriptor chain, and records/logs the HID boot keyboard interface plus its interrupt IN endpoint (`kernel/src/drivers/usb/xhci/mod.rs:2645`).
- **Interrupt endpoint bring-up**: The driver now updates the input control context, provisions a dedicated transfer ring, and issues a 64-byte `Configure Endpoint` (with ICS set) so the HID boot keyboard’s interrupt-IN pipe is live. The ring is primed with an initial normal TRB and the slot doorbell is rung to start polling (`kernel/src/drivers/usb/xhci/mod.rs:3437`).
- **HID interrupt reports**: Transfer events for the boot keyboard now copy the DMA buffer, emit a hex dump for debugging, recycle the capture space, enqueue the next normal TRB, and ring the doorbell so polling continues indefinitely (`kernel/src/drivers/usb/xhci/mod.rs:2105`).
- **HID idle configuration**: A class-specific `SET_IDLE` request keeps the keyboard quiet until its report actually changes, eliminating the stream of zero-filled completions while the system is idle (`kernel/src/drivers/usb/xhci/mod.rs:2050`).
- **Boot report parsing**: The driver now decodes the 8-byte HID boot protocol reports into modifier and usage changes, emitting press/release logs for human-readable keys while tracking state to avoid duplicate events. A tiny ring buffer holds the decoded events so other subsystems (or the monitor `kbd` command) can consume them (`kernel/src/drivers/usb/xhci/mod.rs:2208`, `kernel/src/monitor/mod.rs:439`).
- **Keyboard input hub**: The driver now publishes decoded key transitions through `kernel::input::keyboard`, which owns the shared queue and listener registry. Consumers can either drain the buffer or subscribe for push-style delivery, decoupling the monitor command from the driver internals. The hub also annotates pressed keys with ASCII characters and active modifier snapshots so higher layers can focus on text handling rather than usage decoding (`kernel/src/input/keyboard.rs`, `kernel/src/drivers/usb/xhci/mod.rs:2333`).
- **Interrupt servicing**: xHCI MSI/MSI-X vectors now flow through `service_runtime_interrupt()`, which relies on a `try_lock` guard around the controller list and a deferred-service latch so the idle fallback poll can force a drain if the interrupt path races with it (`kernel/src/drivers/usb/xhci/mod.rs:4726`).

## Observations from QEMU (`./startQemu.sh headless 10`)
- Controller capabilities report `scratchpads=0` on QEMU’s `qemu-xhci`, confirming the scratchpad path is dormant yet safe for hardware that requires it.
- Port summaries show ports 5 and 6 connected at high-speed in `Polling`, aligning with the virtual keyboard and mouse topology.
- With the corrected route string and TRB encodings the controller now posts transfer events for both descriptor TDs, `evaluate-context` returns completion code 1, `configure-endpoint` succeeds, and the logged device/configuration descriptors match QEMU’s virtual keyboard (device `usb=0x0200 vid=0x0627 pid=0x0001`, configuration exposes interface 0 as a HID boot keyboard with endpoint `0x81`).
- The interrupt ring stays armed after each poll; `./startQemu.sh headless 10` now shows MSI-X routing without the deadlock-induced starvation that previously emptied the keyboard buffer. When no keys are pressed we see only the doorbell re-arm trace, confirming the ring recycles quietly until genuine input arrives.
- Background polling now checks the IMAN interrupt-pending bit before touching runtime registers, so the QEMU trace is quiet unless hardware actually signals an event.

## Next Steps
1. Layer a simple line-discipline on top of the ASCII-aware hub (repeat rate, key-combos, control sequences) and expose a stream interface for the shell.
2. Integrate with the upcoming interrupt allocator so MSI/MSI-X vectors can be requested and freed dynamically instead of using the fixed `0x50` bootstrap assignment.
3. Start decoding port status change interrupts to automatically kick off enumeration when devices arrive.
