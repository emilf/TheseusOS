# USB Keyboard Driver – Milestone 3 (xHCI Bring-Up)

Milestone 3 focuses on bringing the xHCI host controller online with modern practices so later stages can layer USB protocol support without revisiting firmware handoff or DMA plumbing.

## Completed Work This Iteration
- **Scratchpad infrastructure**: The driver now decodes `HCSParams2`, allocates the scratchpad pointer table, and provisions aligned DMA buffers when the controller advertises a non-zero count (`kernel/src/drivers/usb/xhci/mod.rs:1242`). DCBAA entry 0 is updated automatically so future slot/context setup can assume the scratchpad array is ready.
- **Capability telemetry**: Capability logging now reports the required scratchpad count alongside slots, ports, and context size, making controller expectations visible in the serial log (`kernel/src/drivers/usb/xhci/mod.rs:1491`).
- **Port diagnostics**: After RUN is asserted the driver walks each root port, emitting a structured summary (link state, speed, power, reset) and highlighting the first connected port to seed enumeration decisions (`kernel/src/drivers/usb/xhci/mod.rs:1569`).
- **Context scaffolding**: Device-context allocations now respect the controller's advertised context size, record the stride once per controller, expose slice-based helpers for slot/endpoint access, prime the input context for the default control endpoint using the first connected port, and immediately issue Enable Slot/Address Device commands to capture the assigned slot ID (`kernel/src/drivers/usb/xhci/mod.rs:1621`).
- **Documentation coverage**: Every helper added for scratchpads and port introspection carries Rustdoc comments so new contributors can follow the flow without cross-referencing the xHCI spec.
- **EP0 control path**: Route-string handling now matches the xHCI expectation (root ports advertise a zero route string), command TRB type constants line up with the spec, and the transfer ring producer no longer rewinds without informing hardware. Together these fixes allow the BSR sequence, evaluate-context, and configure-endpoint commands to succeed, and the driver captures both the 8-byte prefix and the full 18-byte device descriptor under QEMU.
- **Ring lifecycle diagnostics**: Pulling the control transfer ring’s enqueue indices into the debug logs (rather than always dumping TRBs 0–2) makes it obvious which slots are reused across transfers and confirmed that the controller consumes the data stage before raising the status-stage completion.
- **Configuration descriptor discovery**: The enumeration helper now reads the configuration descriptor header, refetches the full descriptor, walks the descriptor chain, and records/logs the HID boot keyboard interface plus its interrupt IN endpoint (`kernel/src/drivers/usb/xhci/mod.rs:2645`).
- **Interrupt endpoint bring-up**: The driver now updates the input control context, provisions a dedicated transfer ring, and issues a 64-byte `Configure Endpoint` (with ICS set) so the HID boot keyboard’s interrupt-IN pipe is live. The ring is primed with an initial normal TRB and the slot doorbell is rung to start polling (`kernel/src/drivers/usb/xhci/mod.rs:3437`).
- **HID interrupt reports**: Transfer events for the boot keyboard now copy the DMA buffer, emit a hex dump for debugging, recycle the capture space, enqueue the next normal TRB, and ring the doorbell so polling continues indefinitely (`kernel/src/drivers/usb/xhci/mod.rs:2105`).
- **HID idle configuration**: A class-specific `SET_IDLE` request keeps the keyboard quiet until its report actually changes, eliminating the stream of zero-filled completions while the system is idle (`kernel/src/drivers/usb/xhci/mod.rs:2050`).
- **Boot report parsing**: The driver now decodes the 8-byte HID boot protocol reports into modifier and usage changes, emitting press/release logs for human-readable keys while tracking state to avoid duplicate events. A tiny ring buffer holds the decoded events so other subsystems (or the monitor `kbd` command) can consume them (`kernel/src/drivers/usb/xhci/mod.rs:2208`, `kernel/src/monitor/mod.rs:439`).
- **Keyboard input hub**: The driver now publishes decoded key transitions through `kernel::input::keyboard`, which owns the shared queue and listener registry. Consumers can either drain the buffer or subscribe for push-style delivery, decoupling the monitor command from the driver internals. The hub also annotates pressed keys with ASCII characters and active modifier snapshots so higher layers can focus on text handling rather than usage decoding (`kernel/src/input/keyboard.rs`, `kernel/src/drivers/usb/xhci/mod.rs:2333`).
- **Interrupt servicing**: xHCI MSI/MSI-X vectors now flow through `service_runtime_interrupt()`, which relies on a `try_lock` guard around the controller list and a deferred-service latch so the idle fallback poll can force a drain if the interrupt path races with it (`kernel/src/drivers/usb/xhci/mod.rs:4726`).
- **Runtime polling toggle**: Introduced `USB_ENABLE_POLLING_FALLBACK` in the kernel config so the idle loop only services controllers that opt into fallback polling. MSI-armed controllers now stay quiet unless an interrupt actually fires, keeping QEMU’s trace output manageable during diagnostics (`kernel/src/config.rs`, `kernel/src/drivers/usb/xhci/mod.rs:4755`).
- **Idle IMAN diagnostics toggle**: Added `USB_IDLE_IMAN_DIAGNOSTICS` so we can *optionally* peek at IMAN.IE/IP in the idle loop when debugging “pending without delivery” scenarios. Default stays `false` so QEMU’s `trace:usb_*` output does not get flooded by IMAN reads (`kernel/src/config.rs`, `kernel/src/drivers/usb/xhci/mod.rs:4815`).
- **MSI-X MVP self-test**: Added `USB_RUN_MSIX_SELF_TEST` (default `true`) to enqueue a NOOP command immediately after MSI/MSI-X enablement and confirm that the completion is observed via the interrupt-driven event-ring path. This gives us a boot-time “interrupt delivery is wired” signal without requiring user input (`kernel/src/config.rs`, `kernel/src/drivers/usb/xhci/mod.rs`).
- **Interrupt enablement**: `start_controller()` now asserts the xHCI `USBCMD` interrupt-enable bit whenever we transition to `RUN`, guaranteeing that MSI/MSI-X deliveries fire once the controller produces an event. The MSI/MSI-X programming path also targets the live LAPIC ID instead of assuming CPU 0, so the message lands on whichever core booted the kernel (`kernel/src/drivers/usb/xhci/mod.rs:2065`).
- **Interrupt diagnostics**: The controller snapshot now captures MSI enablement, programmed vector, and the raw IMAN register (including IE/IP flags) so the `usb summary` monitor command surfaces whether hardware believes an interrupt is pending. We also warn once when IMAN.IE unexpectedly clears while MSI is armed, making it obvious when the controller disarms itself (`kernel/src/drivers/usb/xhci/mod.rs:3747`, `kernel/src/monitor/commands/usb.rs`).
- **MSI-X enable fix**: Corrected the final MSI-X control write so we set `ENABLE` (bit 15) while clearing the function mask (bit 14). QEMU now actually routes completions through vector `0x50` with fallback polling disabled, eliminating the need for the runtime register spam while debugging interrupts (`kernel/src/drivers/usb/xhci/mod.rs:1651`).
- **Event-ring draining fix**: The runtime event consumer no longer uses `IMAN.IP` as a “ring has entries” predicate. QEMU clears `IMAN.IP` after it successfully posts an MSI/MSI-X message, so the correct gate is the TRB cycle bit in the event ring itself. This unblocks interrupt-driven draining and fixes “IMAN.IP set / no keyboard events” regressions when polling is disabled (`docs/external/qemu/usb/hcd-xhci.c`, `kernel/src/drivers/usb/xhci/mod.rs`).
- **Endpoint ID mapping**: For QEMU bring-up, the endpoint-ID mapping must match QEMU’s xHCI EPID encoding: EP1 IN (address `0x81`) maps to endpoint ID **3** (EPn IN = `n*2+1`). Using the wrong encoding results in xHCI ringing `epid 4` which QEMU interprets as USB endpoint 2, causing the virtual keyboard to STALL (`CC_STALL_ERROR`). (`kernel/src/drivers/usb/xhci/mod.rs:3634`, `docs/external/qemu/usb/hcd-xhci.c:3316`).
- **Deferred interrupt drain**: Added a `service_deferred_runtime()` helper so if an MSI fires while the controller list lock is held (for example, by `usb summary`), we can drain the pending event ring once we return to the idle loop—without enabling full polling fallback.
- **Self-test drain guarantee**: The MSI/MSI-X NOOP self-test now performs a single forced drain pass after submission so the completion is observed deterministically even if interrupt delivery is still being debugged.

## Observations from QEMU (`./startQemu.sh headless 10`)
- Controller capabilities report `scratchpads=0` on QEMU’s `qemu-xhci`, confirming the scratchpad path is dormant yet safe for hardware that requires it.
- Port summaries show ports 5 and 6 connected at high-speed in `Polling`, aligning with the virtual keyboard and mouse topology.
- With the corrected route string and TRB encodings the controller now posts transfer events for both descriptor TDs, `evaluate-context` returns completion code 1, `configure-endpoint` succeeds, and the logged device/configuration descriptors match QEMU’s virtual keyboard (device `usb=0x0200 vid=0x0627 pid=0x0001`, configuration exposes interface 0 as a HID boot keyboard with endpoint `0x81`).
- The interrupt ring stays armed after each poll; `./startQemu.sh headless 10` now shows MSI-X routing without the deadlock-induced starvation that previously emptied the keyboard buffer. When no keys are pressed we see only the doorbell re-arm trace, confirming the ring recycles quietly until genuine input arrives.
- Background polling now checks the IMAN interrupt-pending bit before touching runtime registers, so the QEMU trace is quiet unless hardware actually signals an event—and with the new config flag disabled, the idle loop fully yields to MSI delivery unless a deferred-interrupt latch asks for a forced drain.
- The new diagnostics report IMAN.IE/IP status via `usb summary`; initial idle snapshots show IE asserted and IP clear, so we still need logs captured while pressing keys to confirm whether the pending bit ever flips under MSI-only operation.
- After the MSI-X function-mask fix the controller raises vector `0x50` as soon as the HID interrupt endpoint completes, and the idle loop no longer forces `runtime_read` traffic when polling is disabled.

## Next Steps
1. Layer a simple line-discipline on top of the ASCII-aware hub (repeat rate, key-combos, control sequences) and expose a stream interface for the shell.
2. Integrate with the upcoming interrupt allocator so MSI/MSI-X vectors can be requested and freed dynamically instead of using the fixed `0x50` bootstrap assignment.
3. Start decoding port status change interrupts to automatically kick off enumeration when devices arrive.
